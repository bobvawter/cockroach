// Copyright 2019 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"reflect"
	"text/template"

	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
)

func main() {
}

// Eddie generates a contract-enforcer binary.  See discussion on the
// public API for details on the patterns that it looks for.
type Eddie struct {
	Dir      string
	Logger   *log.Logger
	Outfile  string
	Packages []string
}

func (e *Eddie) Execute() error {
	if e.Logger == nil {
		e.Logger = log.New(os.Stdout, "", log.LstdFlags)
	}

	cfg := &packages.Config{
		Dir:  e.Dir,
		Mode: packages.LoadAllSyntax,
	}
	pkgs, err := packages.Load(cfg, e.Packages...)
	if err != nil {
		return err
	}

	// Look up the package name using reflection to prevent any weirdness
	// if the code gets moved to a new package.
	myType := reflect.TypeOf(Eddie{})
	extPkg := path.Join(myType.PkgPath(), "ext")

	// We're looking for some very specific patterns in the original
	// source code, so we're just going to rip through the AST nodes,
	// rather than try to back this out of the SSA form of the implicit
	// init() function.
	//
	// Specifically, we're looking for:
	// var _ Contract = MyContract{}
	// var _ Contract = &MyContract{}
	var contracts []types.Type
	for _, pkg := range pkgs {
		for _, f := range pkg.Syntax {
			for _, d := range f.Decls {
				if v, ok := d.(*ast.GenDecl); ok && v.Tok == token.VAR {
					for _, s := range v.Specs {
						if v, ok := s.(*ast.ValueSpec); ok &&
							len(v.Values) == 1 &&
							v.Names[0].Name == "_" {
							assignmentType, _ := pkg.TypesInfo.TypeOf(v.Type).(*types.Named)
							if assignmentType == nil ||
								assignmentType.Obj().Pkg().Path() != extPkg ||
								assignmentType.Obj().Name() != "Contract" {
								continue
							}
							valueType := pkg.TypesInfo.TypeOf(v.Values[0])
							contracts = append(contracts, valueType)
						}
					}
				}
			}
		}
	}

	// Now that we've found the contracts to link into the enforcer binary,
	// we'll generate the contract registry.
	contracts[0].(*types.Named).Obj().Pkg().Name()

	// Compile the binary.
	tempDir, err := ioutil.TempDir("", "eddie")
	if err != nil {
		return err
	}
	defer func() {
		if err := os.RemoveAll(tempDir); err != nil {
			panic(err)
		}
	}()

	fnMap := template.FuncMap{
		"Contracts": func() []*types.Named {
			ret := make([]*types.Named, len(contracts))
			for idx, c := range contracts {
				switch t := c.(type) {
				case *types.Pointer:
					ret[idx] = t.Elem().(*types.Named)
				case *types.Named:
					ret[idx] = t
				default:
					panic(errors.Errorf("unhandled type %s", reflect.TypeOf(c)))
				}
			}
			return ret
		},
		"ExtPkg": func() string { return extPkg },
		"RtPkg":  func() string { return path.Join(myType.PkgPath(), "rt") },
	}

	t, err := template.New("root").Funcs(fnMap).Parse(`
// File generated by eddie; DO NOT EDIT
package main

import (
	ext "{{ ExtPkg }}"
	rt "{{ RtPkg }}"
	{{ range $idx, $c := Contracts -}}
		c{{ $idx }} "{{ $c.Obj.Pkg.Path }}"
	{{ end }}
)

func main() {
	(&rt.Enforcer{
		Contracts: map[string]func() ext.Contract {
		{{ range $idx, $c := Contracts -}}
			"{{ $c.Obj.Name }}" : func() ext.Contract { return &c{{ $idx }}.{{ $c.Obj.Name}}{} },
		{{ end }}
		},
	}).Main()
}
`)
	if err != nil {
		return err
	}

	var src bytes.Buffer
	if err := t.Execute(&src, nil); err != nil {
		return err
	}

	if formatted, err := format.Source(src.Bytes()); err != nil {
		e.Logger.Print(src.String())
		return err
	} else {
		src.Reset()
		src.Write(formatted)
	}

	main := filepath.Join(tempDir, "main.go")
	if err := ioutil.WriteFile(main, src.Bytes(), 0644); err != nil {
		return err
	}

	exe, err := filepath.Abs(e.Outfile)
	if err != nil {
		return err
	}

	build := exec.Command("go", "build", "-o", exe, main)
	build.Dir = e.Dir
	build.Env = os.Environ()
	if output, err := build.CombinedOutput(); err != nil {
		return errors.Wrapf(err, "%s", output)
	}

	e.Logger.Printf("wrote output to %s", exe)

	return nil
}

// Copyright 2019 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

// Package gen contains the code-generator.
package gen

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"reflect"
	"text/template"

	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
)

// Eddie generates a contract-enforcer binary.  See discussion on the
// public API for details on the patterns that it looks for.
type Eddie struct {
	Dir      string
	KeepTemp bool
	Logger   *log.Logger
	Name     string
	Outfile  string
	Packages []string

	contracts []types.Type
	extPkg    string
	rtPkg     string

	// For testing only, causes the compiled enforcer to be emitted
	// as a golang plugin.
	plugin bool
}

func (e *Eddie) Execute() error {
	if e.Logger == nil {
		e.Logger = log.New(os.Stdout, "", 0 /* no flags */)
	}

	if e.Name == "" {
		return errors.New("no name was set for the output binary")
	}

	if e.Outfile == "" {
		e.Outfile = e.Name
	}

	// Look up the package name using reflection to prevent any weirdness
	// if the code gets moved to a new package.
	myPkg := reflect.TypeOf(Eddie{}).PkgPath()
	myPkg = path.Dir(myPkg)
	e.extPkg = path.Join(myPkg, "ext")
	e.rtPkg = path.Join(myPkg, "rt")

	if err := e.findContracts(); err != nil {
		return err
	}
	if err := e.writeBinary(); err != nil {
		return err
	}
	return nil
}

// findContracts looks for some very specific patterns in the original
// source code, so we're just going to run through the AST nodes, rather
// than try to back this out of the SSA form of the implicit init()
// function.
//
// Specifically, it looks for:
//   var _ Contract = MyContract{}
//   var _ Contract = &MyContract{}
func (e *Eddie) findContracts() error {
	cfg := &packages.Config{
		Dir:  e.Dir,
		Mode: packages.LoadAllSyntax,
	}
	pkgs, err := packages.Load(cfg, e.Packages...)
	if err != nil {
		return err
	}

	for _, pkg := range pkgs {
		for _, f := range pkg.Syntax {
			for _, d := range f.Decls {
				if v, ok := d.(*ast.GenDecl); ok && v.Tok == token.VAR {
					for _, s := range v.Specs {
						if v, ok := s.(*ast.ValueSpec); ok &&
							len(v.Values) == 1 &&
							v.Names[0].Name == "_" {
							assignmentType, _ := pkg.TypesInfo.TypeOf(v.Type).(*types.Named)
							if assignmentType == nil ||
								assignmentType.Obj().Pkg().Path() != e.extPkg ||
								assignmentType.Obj().Name() != "Contract" {
								continue
							}
							valueType := pkg.TypesInfo.TypeOf(v.Values[0])
							e.contracts = append(e.contracts, valueType)
						}
					}
				}
			}
		}
	}

	return nil
}

// writeBinary generates a file containing a main function which
// configures the runtime and then compiles in into an executable
// binary.
func (e *Eddie) writeBinary() error {
	tempDir, err := ioutil.TempDir("", "eddie")
	if err != nil {
		return err
	}
	if !e.KeepTemp {
		defer func() {
			if err := os.RemoveAll(tempDir); err != nil {
				panic(err)
			}
		}()
	}

	fnMap := template.FuncMap{
		"Contracts": func() []*types.Named {
			ret := make([]*types.Named, len(e.contracts))
			for idx, c := range e.contracts {
				switch t := c.(type) {
				case *types.Named:
					ret[idx] = t
				case *types.Pointer:
					ret[idx] = t.Elem().(*types.Named)
				default:
					panic(errors.Errorf("unhandled type %s", reflect.TypeOf(c)))
				}
			}
			return ret
		},
		"ExtPkg": func() string { return e.extPkg },
		"Name":   func() string { return e.Name },
		"RtPkg":  func() string { return e.rtPkg },
	}

	t, err := template.New("root").Funcs(fnMap).Parse(`
// File generated by eddie; DO NOT EDIT
package main

import (
	ext "{{ ExtPkg }}"
	rt "{{ RtPkg }}"
	{{ range $idx, $c := Contracts -}}
		c{{ $idx }} "{{ $c.Obj.Pkg.Path }}"
	{{ end }}
)

var Enforcer = rt.Enforcer{
	Contracts: map[string]func() ext.Contract {
	{{ range $idx, $c := Contracts -}}
		"{{ $c.Obj.Name }}" : func() ext.Contract { return &c{{ $idx }}.{{ $c.Obj.Name}}{} },
	{{ end }}
	},
	Name: "{{ Name }}",
}

func main() {
	Enforcer.Main()
}
`)
	if err != nil {
		return err
	}

	var src bytes.Buffer
	if err := t.Execute(&src, nil); err != nil {
		return err
	}

	// Formatting this code isn't strictly necessary, but it does
	// make it easier to inspect.
	if formatted, err := format.Source(src.Bytes()); err != nil {
		e.Logger.Print(src.String())
		return err
	} else {
		src.Reset()
		src.Write(formatted)
	}

	main := filepath.Join(tempDir, "main.go")
	if err := ioutil.WriteFile(main, src.Bytes(), 0644); err != nil {
		return err
	}

	exe, err := filepath.Abs(e.Outfile)
	if err != nil {
		return err
	}

	args := []string{"build", "-o", exe}
	if e.plugin {
		args = append(args, "-buildmode=plugin")
	}
	args = append(args, main)

	build := exec.Command("go", args...)
	build.Dir = e.Dir
	build.Env = os.Environ()
	if output, err := build.CombinedOutput(); err != nil {
		return errors.Wrapf(err, "%s", output)
	}

	e.Logger.Printf("wrote output to %s", exe)
	return nil
}
